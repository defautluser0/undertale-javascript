<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>UNDERTALE</title>
  <link rel="stylesheet" href="style.css">
</head>

<body>

  <canvas id="gameCanvas" width="640" height="480"></canvas>
  <script type="module">
    import roomSize from '/imports/assets/roomSize.js'

    roomSize.width = 320;  // room width in px
    roomSize.height = 480; // room height in px

  </script>
  <script src="/imports/howler.js"></script>
  <script type="module">
    import { control_update, input_update, keyboard, _key_state } from "/imports/input.js";
		import { instance_create, instances, secondFont, draw_text } from "/imports/assets/gamemakerFunctions.js"
    import { view_current, view_xview, view_yview, updateCamera } from "/imports/view.js"
    import { loadCurrentSong } from "/imports/assets/loadSong.js"
		import global from "/imports/assets/global.js"
    import * as obj_solidtall from '/obj/solidtall/index.js'
    import * as obj_solidlong from '/obj/solidlong/index.js'
    import * as obj_sur from '/obj/sur/index.js'
    import * as obj_sul from '/obj/sul/index.js'
    import * as obj_solidtall_2 from '/obj/solidtall_2/index.js'
    import * as obj_solidsmall from '/obj/solidsmall/index.js'
    import * as obj_mainchara from '/obj/mainchara/index.js'
    import * as obj_sdr from '/obj/sdr/index.js'
    import * as obj_sdl from '/obj/sdl/index.js'
    import * as obj_ruinsmusic from '/obj/ruinsmusic/index.js'
    import * as obj_doorBmusicfade from '/obj/doorBmusicfade/index.js'
    import * as obj_markerA from '/obj/markerA/index.js'
    import * as obj_markerB from '/obj/markerB/index.js'
    import * as obj_toroverworld2 from '/obj/toroverworld2/index.js'
    import * as obj_doorA from '/obj/doorA/index.js'
    import * as obj_savepoint from '/obj/savepoint/index.js'
    import * as obj_toribuster from '/obj/toribuster/index.js'
    import * as obj_overworldcontroller from '/obj/overworldcontroller/index.js'
		import * as screenUpdater from '/obj/screen/index.js'

		const allInstances = [];

    loadCurrentSong("currentsong")
    loadCurrentSong("currentsong2")

    instance_create(20, 0, obj_solidtall);
    instance_create(280, 0, obj_solidtall);
    instance_create(100, 180, obj_sur);
    instance_create(80, 160, obj_sur);
    instance_create(200, 180, obj_sul);
    instance_create(220, 160, obj_sul);
    instance_create(40, 120, obj_sul);
    instance_create(260, 120, obj_sur);
    instance_create(40, 220, obj_solidtall_2);
    instance_create(40, 260, obj_solidtall_2);
    instance_create(40, 300, obj_solidtall_2);
    instance_create(260, 220, obj_solidtall_2);
    instance_create(260, 260, obj_solidtall_2);
    instance_create(260, 300, obj_solidtall_2);
    instance_create(40, 340, obj_solidtall_2);
    instance_create(40, 380, obj_solidtall_2);
    instance_create(260, 340, obj_solidtall_2);
    instance_create(260, 380, obj_solidtall_2);
    instance_create(200, 140, obj_solidsmall);
    instance_create(180, 140, obj_solidsmall);
    instance_create(160, 140, obj_solidsmall);
    instance_create(140, 140, obj_solidsmall);
    instance_create(120, 140, obj_solidsmall);
    instance_create(100, 140, obj_solidsmall);
    instance_create(260, 180, obj_sdr);
    instance_create(60, 400, obj_sdl);
    instance_create(240, 400, obj_sdr);
    instance_create(80, 420, obj_solidsmall);
    instance_create(100, 420, obj_solidsmall);
    instance_create(120, 440, obj_solidsmall);
    instance_create(180, 440, obj_solidsmall);
    instance_create(100, 160, obj_solidsmall);
    instance_create(200, 160, obj_solidsmall);
    instance_create(120, 420, obj_sdl);
    instance_create(180, 420, obj_sdr);
    instance_create(80, 140, obj_solidsmall);
    instance_create(220, 140, obj_solidsmall);
    instance_create(120, 180, obj_solidsmall);
    instance_create(180, 180, obj_solidsmall);
    instance_create(120, 160, obj_solidsmall);
    instance_create(180, 160, obj_solidsmall);
    instance_create(60, 220, obj_solidsmall);
    instance_create(40, 180, obj_sdl);
    instance_create(60, 200, obj_sdl);
    instance_create(240, 200, obj_sdr);
    instance_create(240, 220, obj_solidsmall);
    instance_create(200, 420, obj_solidlong);
    instance_create(0, 100, obj_solidlong);
    instance_create(0, 460, obj_solidlong);
    instance_create(22, 194, obj_ruinsmusic);
    instance_create(140, 451, obj_doorBmusicfade);
    instance_create(160, 451, obj_doorBmusicfade);
    instance_create(160, 420, obj_markerA);
    instance_create(150, 112, obj_markerB);
    instance_create(142, 320, obj_toroverworld2);
    instance_create(140, 100, obj_doorA);
    instance_create(160, 100, obj_doorA);
    instance_create(150, 190, obj_savepoint);
    instance_create(150, 86, obj_toribuster);
    instance_create(150, 200, obj_mainchara);
    instance_create(20, 220, obj_overworldcontroller);
    screenUpdater.create()

    if (global.room_persistent === window.location.href) {
      const save = global._roomSaves?.[window.location.href];
      if (save) {
        for (const { objName, data } of save) {
          // Try to find the object by name in current instances map keys
          let obj = null;
          for (const candidates of instances.values()) {
            for (const inst of candidates) {
              if (inst.name === objName) {
                obj = inst;
                obj.saved = true;
                inst.saved = false;
                console.log(obj.saved, inst.saved);
                break;
              }
            }
          }

          if (!obj) {
            console.warn(`Object with name "${objName}" not found, skipping instance`);
            continue;
          }
          const instance = obj._object?.create?.();
          if (!instance) {
            console.error(`instance ${objName}.create() is invalid or null`); continue;
          }
          instance._object = obj._object;
          Object.defineProperties(instance, Object.getOwnPropertyDescriptors(data));
          Object.defineProperties(instance, Object.getOwnPropertyDescriptors(instance._object));
        
          instance.startx = instance.x;
          instance.starty = instance.y;
          instance.xstart = instance.x;
          instance.ystart = instance.y;

          if (!instances.get(obj._object)[0].saved) instances.set(obj._object, []);

          instances.get(obj._object).push(instance);

          obj.roomStart?.call(instance);
        };
      }
    }

    // gameloop DO NOT EDIT VARIABLES UNLESS NECESSARY (eg. changing fps in this room for some reason)
    // IMPORTANT: replace "obj_objectname" with the object name (eg. obj_mainchara) and import it from /obj/objectname/index.js above
    const FPS = 30;
    const FRAME_DURATION = 1000 / FPS;
    let lastFrameTime = 0;
    let fpsCounter = 0;
    let lastFpsUpdate = performance.now();
    let currentFps = 0;
    function game_loop(currentTime) {
      const elapsed = currentTime - lastFrameTime;

      allInstances.length = 0;

      if (elapsed >= FRAME_DURATION) {
        lastFrameTime = currentTime;

        fpsCounter++;

        const now = currentTime;
        if (now - lastFpsUpdate >= 1000) {
          currentFps = fpsCounter;
          fpsCounter = 0;
          lastFpsUpdate = now;
        }
        
        control_update();
        screenUpdater.beginStep();
        for (const [obj, instanceList] of instances) {
          for (const instance of instanceList) {
            obj.beginStep?.call(instance);
          }
        }
        for (const [obj, instanceList] of instances) {
          for (const instance of instanceList) {
            obj.updateAlarms?.call(instance);
          }
        }
        for (const [obj, instanceList] of instances) {
          for (const instance of instanceList) {
            obj.step?.call(instance);
          }
        }
        for (const [obj, instanceList] of instances) {
          for (const instance of instanceList) {
            obj.followPath?.call(instance);
          }
        }
        screenUpdater.endStep();
        for (const [obj, instanceList] of instances) {
          for (const instance of instanceList) {
            obj.endStep?.call(instance);
          }
        }
        for (const [obj, instanceList] of instances) {
          for (const instance of instanceList) {
            allInstances.push({ obj, instance });
          }
        }

        allInstances.sort((a, b) => b.instance.depth - a.instance.depth);

        for (const { obj,  instance } of allInstances) {
          obj.updateSprite?.call(instance);
          obj.draw?.call(instance);
        }

        if (global.debug === 1 && secondFont) {
          draw_text(15 + view_xview[view_current], 15 + view_yview[view_current], currentFps, 1);
        }

        for (const [obj, instanceList] of instances) {
          for (const instance of instanceList) {
            obj.updateGamemakerFunctions?.call(instance);
          }
        }

        updateCamera(instances.get(obj_mainchara)[0]) // replace obj_objectname with your centered object or instances.get(...)[0] with {x: 0, y: 0} for no screen centering
        screenUpdater.updateScreen();

        input_update();

        if (global.roomEnd && !global.eventDone) {
          global.eventDone = true;
          for (const [obj, instanceList] of instances) {
            for (const instance of instanceList) {
              obj.roomEnd?.call(instance);
            }
          }
        }

        if (global.roomEnd && global.eventDone && global.nextRoom !== null && "https://undertale.defautluser0.xyz" + global.nextRoom !== window.location.href) {
          global.eventDone = false;
          let nextRoom = global.nextRoom
          global.nextRoom = null;
          window.location.href = nextRoom;
        }
      }

      requestAnimationFrame(game_loop);
    }

		window.addEventListener("keydown", e => {
      keyboard[e.code] = true;
      _key_state[e.code] = true;
    });
    window.addEventListener("keyup", e => {
      keyboard[e.code] = false;
      _key_state[e.code] = false;
    });

    // room code (object positioning and such) goes here

    // starts the game loop once everything has been defined
    window.addEventListener('load', () => {
      requestAnimationFrame(game_loop);
    })
  </script>
</body>

</html>